(function(f){if(typeof exports==="object"&&typeof module!=="undefined"){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.tdDefaults = f()}})(function(){var define,module,exports;return (function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({1:[function(require,module,exports){
const {defaultLookup, defaultClasses} = require("./src/definitions")
const {sharedDefaults, sharedDataSchema, sharedOneObject} = require("./src/shared")
const {objEquality} = require( './src/util' )

/**
 * Extends a given TD with the default values of fields that aren't filled.
 * @param {object} td The TD to extend with default values
 * @returns {void}
 */
function addDefaults(td) {
    sharedDefaults(td, extendOneObject, extendDataSchema)
}

/**
 * Remove explicitly given default values from a TD.
 * @param {object} td The TD to remove default values from
 * @returns {void}
 */
function removeDefaults(td) {
    sharedDefaults(td, reduceOneObject, reduceDataSchema)
}

/**
 * Recursively extends nested data Schemas
 * @param {object} dataSchema A TD dataSchema object
 */
function extendDataSchema(dataSchema) {
    sharedDataSchema(dataSchema, extendOneObject)
}

/**
 * Recursively reduces nested data Schemas
 * @param {object} dataSchema A TD dataSchema object
 */
function reduceDataSchema(dataSchema) {
    sharedDataSchema(dataSchema, reduceOneObject)
}


/**
 * Adds default values to one given object,
 * using the defaultLookup table
 * @param {{}} target the object to extend
 * @param {string} type The type according to the defaultLookup table
 * @param {{}} parentInteraction Only for read/writeOnly special case
 */
function extendOneObject(target, type, parentInteraction) {

    const callback = (cTarget, cType, cParent) => {
        // treat special case, that readOnly / writeOnly should be respected
        if (cType === "Form-PropertyAffordance" && (cParent.readOnly || cParent.writeOnly)) {
            if (cTarget.op === undefined) {
                if (cParent.readOnly && cParent.writeOnly) {
                    console.warn("readOnly and writeOnly are both true for: ", cParent)
                    // do not set op in this case
                }
                else if (cParent.readOnly) {
                    cTarget.op = "readproperty"
                }
                else {
                    cTarget.op = "writeproperty"
                }
            }
        }
        // default behavior
        else {
            const defaultSource = defaultLookup[cType]

            if (cType === "AdditionalExpectedResponse" && cParent.contentType) {
                defaultSource.contentType = cParent.contentType
            }

            Object.keys(defaultSource).forEach( key => {
                if (cTarget[key] === undefined) {
                    cTarget[key] = defaultSource[key]
                }
            })
        }
    }

    sharedOneObject(target, type, callback, parentInteraction)
}

/**
 * Remove properties from one object if they
 * equal default values, using the defaultLookup table
 * @param {object} target the object to extend
 * @param {string} type The type according to the defaultLookup table
 * @param {{}} parentInteraction Only for read/writeOnly special case
 */
function reduceOneObject(target, type, parentInteraction) {

    const callback = (cTarget, cType, cParent) => {
        // treat special case, that readOnly / writeOnly should be respected
        if (cType === "Form-PropertyAffordance" && (cParent.readOnly || cParent.writeOnly) && typeof cTarget.op === "string") {
            if (cParent.readOnly && cParent.writeOnly) {
                console.warn("readOnly and writeOnly are both true for: ", cParent)
                // do not set op in this case
            }
            else if (cParent.readOnly && cTarget.op === "readproperty") {
                delete cTarget.op
            }
            else if (cParent.writeOnly && cTarget.op === "writeproperty") {
                delete cTarget.op
            }
            else {
                // do nothing
            }
        }
        else {
            const defaultSource = defaultLookup[cType]

            if (cType === "AdditionalExpectedResponse" && cParent.contentType) {
                defaultSource.contentType = cParent.contentType
            }

            Object.keys(defaultSource).forEach( key => {
                if (objEquality(cTarget[key], defaultSource[key])) {
                    delete cTarget[key]
                }
            })
        }
    }

    sharedOneObject(target, type, callback, parentInteraction)
}

module.exports = {
    addDefaults,
    removeDefaults,
    extendDataSchema,
    extendOneObject,
    reduceDataSchema,
    reduceOneObject,
    defaultLookup,
    defaultClasses
}

},{"./src/definitions":2,"./src/shared":3,"./src/util":4}],2:[function(require,module,exports){
/**
 * the TD default value definitions according to
 * https://www.w3.org/TR/2020/REC-wot-thing-description-20200409/
 *
 * represented with:
 * class[-superClass] -> property -> value
 */
const defaultLookup = {
    Form: {
        contentType: "application/json"
    },
    "Form-PropertyAffordance": {
        op: ["readproperty", "writeproperty"]
    },
    "Form-ActionAffordance": {
        op: "invokeaction"
    },
    "Form-EventAffordance": {
        op: ["subscribeevent", "unsubscribeevent"]
    },
    AdditionalExpectedResponse: {
        success: false,
        contentType: "application/json"
    },
    DataSchema: {
        readOnly: false,
        writeOnly: false
    },
    PropertyAffordance: {
        observable: false
    },
    ActionAffordance: {
        safe: false,
        idempotent: false
    },
    BasicSecuritySchema: {
        in: "header"
    },
    DigestSecurityScheme: {
        in: "header",
        qop: "auth"
    },
    BearerSecurityScheme: {
        in: "header",
        alg: "ES256",
        format: "jwt"
    },
    APIKeySecurityScheme: {
        in: "query"
    }
}

/**
 * The possible types of objects to extend
 */
const defaultClasses = {
    form: "Form",
    formPropertyAffordance: "Form-PropertyAffordance",
    formActionAffordance: "Form-ActionAffordance",
    formEventAffordance: "Form-EventAffordance",
    additionalExpectedResponse: "AdditionalExpectedResponse",
    dataSchema: "DataSchema",
    propertyAffordance: "PropertyAffordance",
    actionAffordance: "ActionAffordance",
    basicSecuritySchema: "BasicSecuritySchema",
    digestSecurityScheme: "DigestSecurityScheme",
    bearerSecurityScheme: "BearerSecurityScheme",
    apiKeySecurityScheme: "APIKeySecurityScheme"
}

module.exports = {defaultLookup, defaultClasses}

},{}],3:[function(require,module,exports){
/**
 * functionality shared by `extend` and `reduce` functions
 */
const {defaultLookup, defaultClasses} = require("./definitions")
const {forEvery} = require("./util")


/**
 * Extends/Reduces a given TD with the default values of fields that aren't/are filled.
 * @param {object} td The TD to extend with default values
 * @param {function} cbOneObject extendOneObject or reduceOneObject
 * @param {function} cbDataSchema extendDataSchema or reduceDataSchema
 * @returns {void}
 */
function sharedDefaults(td, cbOneObject, cbDataSchema) {
    if (typeof td !== "object") {
        throw new Error("Typeof TD has to be object, not: " + typeof td)
    }

    // -- Property Affordances
    forEvery(td.properties, property => {
        cbOneObject(property, defaultClasses.propertyAffordance)
    })

    // -- Action Affordances
    forEvery(td.actions, action => {
        cbOneObject(action, defaultClasses.actionAffordance)
    })

    // -- Forms
    const interactionTypes = {
        properties: defaultClasses.formPropertyAffordance,
        actions: defaultClasses.formActionAffordance,
        events: defaultClasses.formEventAffordance
    }
    Object.keys(interactionTypes).forEach( interactionType => {
        forEvery(td[interactionType], interaction => {
            if (interaction.forms) {
                interaction.forms.forEach( form => {
                    cbOneObject(form, interactionTypes[interactionType], interaction)

                    if (form.additionalResponses) {
                        form.additionalResponses.forEach(response => {
                            cbOneObject(response, defaultClasses.additionalExpectedResponse, form)
                        })
                    }
                })
            }
        })
    })
    if (td.forms) {
        td.forms.forEach( form => {
            cbOneObject(form, defaultClasses.form)

            if (form.additionalResponses) {
                form.additionalResponses.forEach(response => {
                    cbOneObject(response, defaultClasses.additionalExpectedResponse, form)
                })
            }
        })
    }

    // -- DataSchema
    forEvery(td.properties, cbDataSchema)
    forEvery(td.actions, action => {
        if(action.input) {cbDataSchema(action.input)}
        if(action.output) {cbDataSchema(action.output)}
    })
    forEvery(td.events, event => {
        if(event.subscription) {cbDataSchema(event.subscription)}
        if(event.data) {cbDataSchema(event.data)}
        if(event.cancellation) {cbDataSchema(event.cancellation)}
    })
    Object.keys(interactionTypes).forEach( interactionType => {
        forEvery(td[interactionType], interaction => {
            forEvery(interaction.uriVariables, cbDataSchema)
        })
    })

    // -- SecurityScheme's (Basic, Digest, Bearer, APIKey)
    const secSchemes = {
        basic: defaultClasses.basicSecuritySchema,
        digest: defaultClasses.digestSecurityScheme,
        bearer: defaultClasses.bearerSecurityScheme,
        apikey: defaultClasses.apiKeySecurityScheme
    }
    if (td.securityDefinitions) {
        forEvery(td.securityDefinitions, securityDefinition => {
            const aSecScheme = Object.keys(secSchemes).find(secScheme => secScheme === securityDefinition.scheme)
            if (aSecScheme !== undefined) {
                cbOneObject(securityDefinition, secSchemes[aSecScheme])
            }
        })
    }
}

/**
 * Recursively extends/reduces nested data Schemas
 * @param {object} dataSchema An Td dataSchema object
 * @param {(target:object, type:string)=>void} callback extendOneObject or reduceOneObject
 */
function sharedDataSchema(dataSchema, callback) {
    callback(dataSchema, defaultClasses.dataSchema)

    if (dataSchema.oneOf) {
        dataSchema.oneOf.forEach(childScheme => {
            sharedDataSchema(childScheme, callback)
        })
    }
    if (dataSchema.items) {
        if (Array.isArray(dataSchema.items)) {
            dataSchema.items.forEach(item => {
                sharedDataSchema(item, callback)
            })
        }
        else {
            sharedDataSchema(dataSchema.items, callback)
        }
    }
    if (dataSchema.properties) {
        Object.keys(dataSchema.properties).forEach(key => {
            sharedDataSchema(dataSchema.properties[key], callback)
        })
    }
}

/**
 * Add/Remove default values to one given object,
 * using the defaultLookup table
 * @param {{}} target the object to extend
 * @param {string} type The type according to the defaultLookup table
 */
function sharedOneObject(target, type, callback, parentInteraction) {
    if (typeof target !== "object") {throw new Error("target has to be of type 'object' not: " + typeof target)}
    if (typeof type !== "string") {throw new Error("type has to be of type 'string' not: " + typeof type)}
    if (Object.keys(defaultLookup).every(key => (key !== type))) {
        throw new Error("type has to be a defaultLookup entry, type: " + type)
    }

    callback(target, type, parentInteraction)

    // handle default values with superClasses (e.g. Form-EventAffordance)
    if (type.includes("-")) {
        const superType = type.split("-").slice(0,-1).join("-")
        sharedOneObject(target, superType, callback)
    }
}

module.exports = {sharedDefaults, sharedDataSchema, sharedOneObject}

},{"./definitions":2,"./util":4}],4:[function(require,module,exports){
const {defaultLookup} = require("./definitions")

/**
 * Applies the specified callback to every element of an object
 * (like forEach does on an Array)
 * @param {object} obj the target object
 * @param {(element:any)=>void} callback function to apply for every element
 */
function forEvery(obj, callback) {
    if (typeof obj === "object" && !Array.isArray(obj)) {
        Object.keys(obj).forEach( key => {
            const element = obj[key]
            callback(element)
        })
    }
}

/**
 * Compare two variables for equality
 * (deep equality on objects)
 * (order doesn't matter on arrays, duplicates are allowed)
 * @param {any} objA value A
 * @param {any} objB value B
 * @returns {boolean} are both variables equal
 */
function objEquality(objA, objB) {
    if (typeof objA !== "object" || typeof objB !== "object") {
        return (objA === objB)
    }
    else {
        // order shouldn't matter for an array
        if (Array.isArray(objA) && Array.isArray(objB)) {
            return (
                objA.every(elA => objB.some(elB => objEquality(elA, elB)))
                &&
                objB.every(elB => objA.some(elA => objEquality(elA, elB)))
            )
        }
        else {
            return (
                Object.keys(objA).every( keyA => (objB[keyA] && objEquality(objA[keyA], objB[keyA])))
                &&
                Object.keys(objB).every( keyB => (objA[keyB] && objEquality(objA[keyB], objB[keyB])))
            )
        }
    }
}

module.exports = {forEvery, objEquality}

},{"./definitions":2}]},{},[1])(1)
});
